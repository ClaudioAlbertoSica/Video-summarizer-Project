import { useContext, useEffect, useRef, useState } from "react";
import { LoggedUserContext } from "../../../ActiveUserContext";
import server from "../../../Services/serverCall";
import "./WIP.css";
import ActiveWorkIndicator from "./ActiveWorkIndicator";
import ReadyWorkIndicator from "./ReadyWorkIndicator";
import { DBuser, LoggedUser } from "../../../Services/Types/UserTypes";
import { PaletteMode } from "@mui/material";

function WIPindicator() {
  const activeUSer = useContext(LoggedUserContext);
  const intervalID = useRef<number[]>([]); /*This stores the id of the setInterval, to allow
   me to cancel it.
   I used an array, because as React renders everything twice while developing, I need to catch 
   IDs generated by both renders, and any other render triggered done by other processes.
   */
  const [showIsWorking, setShowIsWorking] = useState<boolean>(activeUSer.userState.inProgress);
  const checkServerStatus = useRef<boolean>(activeUSer.userState.inProgress);

  const checkInProgress = async () => {
    await server
      .get<boolean>(`/inprogress/${activeUSer.userState.id}`)
      .then((res) => {
        console.log(res.data);
        if (!res.data) {
          const update = async () => {
            await UpdateLoggedUserFromDB();
          };
          update();
        }
        return res;
      })
      .then((res) => {
        console.log("response: " + res.data);
        if (!res.data /*meanning "server has no work in progress"*/) {
          clearIntervals(); //If server is not working anymore, all setInterval() are stopped
          checkServerStatus.current = false;

          const newActiveUser: LoggedUser = { ...activeUSer.userState };
          newActiveUser.inProgress = false;
          activeUSer.userSteState(newActiveUser);
        }
        console.log(checkServerStatus.current);
        setShowIsWorking(res.data);
      })
      .catch((err) => console.log(err.error));
  };

  const clearIntervals = () => {
    while (intervalID.current.length != 0) {
      const removedElement = intervalID.current.pop();
      clearInterval(removedElement);
      console.log("all intervals cleared");
    }
  };

  const UpdateLoggedUserFromDB = async () => {
    await server
      .get<DBuser>(`/${activeUSer.userState.id}`)
      .then((res) => {
        const adjustedUser: LoggedUser = newUserTypesCorrections(res.data);
        activeUSer.userSteState(adjustedUser);
      })
      .catch((err) => {
        throw new Error(err.error);
      });
  };

  const newUserTypesCorrections = (newUSer: DBuser) => {
    /*Some types need to be adjusted, because they differ in the fron-web, from the server. 
  isDark is a boolean in the server, while it is a PaletteMode-string like in the front-web*/
    const adjustedUser: LoggedUser = newUSer.config.isDark
      ? { ...newUSer, config: { isDark: "dark" as PaletteMode } }
      : { ...newUSer, config: { isDark: "light" as PaletteMode } };

    return adjustedUser;
  };

  useEffect(() => {
    if (checkServerStatus.current) {
      setShowIsWorking(true);
      intervalID.current.push(setInterval(() => checkInProgress(), 3000));
      console.log("I was here (true)" + activeUSer.userState.inProgress);
    } else {
      checkServerStatus.current = true;
      console.log("I was here (false)" + activeUSer.userState.inProgress);
    }
  }, [activeUSer.userState.inProgress]);

  return <>{showIsWorking ? <ActiveWorkIndicator /> : <ReadyWorkIndicator />}</>;
}

export default WIPindicator;
