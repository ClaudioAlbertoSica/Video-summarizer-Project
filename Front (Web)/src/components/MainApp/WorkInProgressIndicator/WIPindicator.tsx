import { useContext, useEffect, useRef, useState } from "react";
import { LoggedUserContext } from "../../../ActiveUserContext";
import server from "../../../Services/serverCall";
import "./WIP.css";
import ActiveWorkIndicator from "./ActiveWorkIndicator";
import ReadyWorkIndicator from "./ReadyWorkIndicator";
import { LoggedUser } from "../../../Services/Types/UserTypes";

function WIPindicator() {
  const activeUSer = useContext(LoggedUserContext);
  const intervalID = useRef<number[]>([]); /*This stores the id of the setInterval, to allow
   me to cancel it.
   I used an array, because as React renders everything twice while developing, I need to catch 
   IDs generated by both renders, and any other render triggered done by other processes.
   */
  const [showIsWorking, setShowIsWorking] = useState<boolean>(activeUSer.userState.inProgress);
  const checkServerStatus = useRef<boolean>(activeUSer.userState.inProgress);

  const checkInProgress = async () => {
    await server
      .get<boolean>(`/inprogress/${activeUSer.userState.id}`)
      .then((res) => {
        console.log("response: " + res.data);
        if (!res.data /*meanning "server has no work in progress"*/) {
          clearIntervals(); //If server is not working anymore, all setInterval() are stopped
          checkServerStatus.current = false;
          const newActiveUser: LoggedUser = activeUSer.userState;
          newActiveUser.inProgress = false;
          activeUSer.userSteState(newActiveUser);
        }
        console.log(checkServerStatus.current);
        setShowIsWorking(res.data);
      })
      .catch((err) => console.log(err.error));
  };

  useEffect(() => {
    if (checkServerStatus.current) {
      setShowIsWorking(true);
      intervalID.current.push(setInterval(() => checkInProgress(), 3000));
      console.log("I was here (true)");
    } else {
      const newActiveUser: LoggedUser = activeUSer.userState;
      newActiveUser.inProgress = false;
      activeUSer.userSteState(newActiveUser);
      checkServerStatus.current = true;
      console.log("I was here (false)");
    }
  }, [activeUSer.userState.inProgress]);

  const clearIntervals = () => {
    while (intervalID.current.length != 0) {
      const removedElement = intervalID.current.pop();
      clearInterval(removedElement);
      console.log("all intervals cleared");
    }
  };

  return <>{showIsWorking ? <ActiveWorkIndicator /> : <ReadyWorkIndicator />}</>;
}

export default WIPindicator;
